# Домашнє завдання 4

Для порівняння ефективності алгоритмів, я використав бібліотеку timeit на списку 
з 1000 випадковим образом згенерованих цілих чисел в діапазоні від 0 до 1000. Після чого, 
сортування кожним методом виконувалось 100 разів та бібліотека підрахувала середній час виконання.

| Метод          | Час, s                 |
|----------------|------------------------|
| Insertion sort | 0.028325700026471168   |
| Merge sort     | 0.14670489996206015    |
| Tim sort       | 0.00035440002102404833 |
| Tim sorted     | 0.0005228999652899802  |

В результаті, алгоритм Merge sort використовує найбільшу кількість часу. Водночас, 
алгоритм Tim sort є найшвидшим. Відмічається також різниця між використанням list.sort() та sorted(), 
перший метод виконується швидше, що скоріш за все спричинено тим, що sorted() створює копію списку, 
а sort() змінює його. 

Якщо виконати обчислення з обмеженням, що список 
буде копіюватися у всіх алгоритмах, які виконували 
inplace сортування, то різниця в часі стане менш 
значною між sort() та sorted(), і більш значною 
в порівнянні з іншими алгоритмами.

| Метод          | Час, s                |
|----------------|-----------------------|
| Insertion sort | 2.116425900021568     |
| Merge sort     | 0.19786689995089546   |
| Tim sort       | 0.00531610002508387   |
| Tim sorted     | 0.0052408999763429165 |

